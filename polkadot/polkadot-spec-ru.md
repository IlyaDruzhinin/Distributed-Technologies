# Спецификация Polkadot
- исходник лежит здесь: https://github.com/w3f/polkadot-spec/blob/master/spec.md
- версия перевода: 20.06.2018

## Введение

Polkadot прежде всего, описывается как протокол `Relay chain`; ключевая логика parachain протоколов, скорее всего будет разделяться между конкретными реализациями `parachain`, но не являтся частью протокола Polkadot.

# Relay chain

Relay chain это упрощенный proof-of-stake блокчейн с движком Web Assembly (Wasm). В отличии от Ethereum и Bitcoin, балансы не являются значимой частью т.н. функции по изменению состояния (state-transition function (STF)). Действительно, единственный аспект релейной цепи, который является первоклассным - это понятие `объект`. Каждый объект идентифицируется через индекс (`ObjectID`) и имеет некоторый код и хранилище (аналогично контрактам аккаунтов в Ethereum). Код экспортирует функции, которые могут быть вызваны либо из других объектов, либо через транзакции.

Практически говоря, балансы аккаунтов существуют в релейной цепи, но полностью являются артефактом хранилища и кода объекта. Весь переход состояния управляется через одиночные вызовы в определенный объект, называемый "Administration". Помимо алгоритма консенсуса (который "жестко закодирован" в проколе для практичности легкого клиента), все аспекты прокола программируеются как логика этих объектов и могут быть обновлены без какого-либо жесткого форка.

## Консенсус

Консенсус определяет как работает блокчейн и следовательно кколлекциую переход состояния от генезиса к вершине, согласованых между всех совместимых клиентов и постоянно прогрессирует. Он отделен от остальной части обработки блоков и образует "жестко закодированную" часть протокола, не обрабатываемую средой исполнения обхектов Wasm. Это в первую очередь сделано, потому что это сделало бы реализацию клиента чрезвычайно трудной и в заничительной степени исключило бы множественные стратегии формирования консенсуса, которые могли бы добавить существенную надежность сети.

Он управляется в трех частях:

механизм мгновенного завершения, который обеспечивает проверяемую вперед окончательность на одном блоке релейной цепи (в конечном итоге, вероятно, на основе Zyzzyva/Aardvark/Abab. См. Раздел ниже для основанного на PBFT алгоритма, используемого в ранних PoCs);
в parachain кандидат в определении процедуры, которая обеспечивает возможность формирования консенсуса по ряду parachain кандидатов, которые удовлетворяют определенным критериям, на основе подписанных заявлений от проверяющих;
механизм сопоставления набора транзакций ретрансляционной цепочки для определения подписанных, связанных транзакций.

Из трех атрибутов консенсуса, а именно: согласованность, доступность и толерантность к разделам, мы, как правило, готовы отказаться от крупномасштабного допуска к разделам набора валидаторов (которого мы можем сильно мотивировать, чтобы они оставались в сети и хорошо связаны), и получить соответствующие гарантии согласованности и доступности. Как таковой алгоритм консенсуса мгновенного завершения хорошо подходит, например, PBFT или оптимистическая производная, такая как Zyzzyva.

Точки 2 и 3 являются частью одной и той же базовой потребности определить блок, который будет завершен среди всех валидаторов как точка 1. Единственный аспект блока, который должен быть определен (т. е. единственная часть блока, которая является недетерминированной),-это набор транзакций, который включен. Это касается как отбора кандидатов parachain и внешней интеграции сделки. (Кандидаты Parachain выбраны путем включения конкретной сделки.)

Окончательный алгоритм выбора кандидата на парашют, вероятно, будет распределен и прогрессивен, что даст как большую эффективность, так и более изящную деградацию и приведет к меньшему количеству артефактов, которые потенциально могут вызвать дыры в безопасности. Для PoC-1 будет использоваться гораздо более централизованный механизм, основанный на повышенном наборе лидеров групп для сопоставления и определения кандидатов на парашют.

### PoC-1 Parachain candidate selection

Каждый блок, каждый валидатор детерминистически присваивается (через функцию CSPRNG) одному парашюту или релейной цепи. Есть ровно один валидатор, который является назначенным руководителем для каждого parachain и ровно через валидатор, который предназначен для реле-цепь.

```
let block_number := S.Nobody.block_number()
let (v.home_chain, v.is_leader) := determine_role(v, block_number)
```

`v.home_chain` может быть индекс parachain или реле.

Если валидатор является лидером, они будут выберите правильный parachain кандидата от блока (который предполагается, будет обеспечиваться сортировщиков parachain), подписать его и направить друг другу оценщика, присвоенный этому parachain.


```
let h := keccak256(block_number ++ 'valid' ++ v.home_chain ++ candidate)

if v.is_leader:
	do:
		let c := find_candidate(v.home_chain)
	loop unless is_valid(c) and all_ingress_data_known(c) then let candidate := c
	let sig := v.sign(h)
	let groupies := every w in validators where:
		determine_role(w, block_number).home_chain == v.home_chain and w != v

	let attests := []
	for w in groupies
		w.send('request_attest' ++ candidate ++ sig).on_reply(r):
			if r == 'attest' ++ sig where recover(sig, h) == w and !attests.contains(w):
				attests.push(w => sig)

	await attests.count == attest_min:
		let relay := w in validators where determine_role(w, block_number).home_chain == Relay
		relay.send(h ++ sig ++ concat_values_of(attests))
else if v.home_chain != Relay:
	let leader := w in validators where
		determine_role(w, block_number).home_chain == v.home_chain and v.is_leader
	await leader.received(msg):
		if let msg == 'request_attest' ++ candidate ++ sig:
			if recover(sig, h) == leader and is_valid(candidate) and all_ingress_data_known(candidate):
				let sig := v.sign(h)
				leader.send('attest' ++ sig)
else
	wait for all parachain validators to send properly attested block or timeout
	author block
```

Каждый другой валидатор подпишет и ответит подтверждением того, что вся информация, относящаяся к этому блоку, доступна, включая внешнюю информацию, такую как транзакции и внешне зависимую информацию, такую как данные выходной очереди. Подписывая эту аттестацию, валидаторы обещают предоставить эту информацию любому другому валидатору как минимум для блоков era_length.

Для того чтобы кандидат считался безопасным, должен быть установлен строгий минимум аттестаций (пока не определен, но называется attest_min). Набор attest_min + 1 подписей вместе с кандидатом parachain хэш затем ретранслировать валидатору места в цепи реле.

Валидатор, назначенный для релейной цепи, собирает транзакции для блока релейной цепи и, по получении всех (при условии разумного тайм-аута) должным образом подписанных/аттестованных кандидатов на парашют, строит и ретранслирует окончательный блок каждому валидатору вместе со всеми подписями. Каждая валидатором чтобы убедиться, что все кандидаты parachain должным образом засвидетельствовано. Заголовок заключительного блока затем хэшируется и используется в алгоритме завершения.

Рассмотрим: выделение большого подмножества валидаторов CSPRNG (возможно, 33% + 1) Для выбора транзакций. Подмножество упорядочено в степенной распределение транзакций. Те, кому выделено большее количество транзакций, также имеют более высокий приоритет (и фактически ставят под сомнение валидаторы более низкого порядка), что означает, что в большинстве случаев первых нескольких участников достаточно, чтобы получить консенсус по набору транзакций. В случае неисправного узла валидаторы более низкого порядка, действующие в совокупности, позволяют важным (например, жалобам) транзакциям проникать в блок.

### PoC Consensus Algorithm

Это алгоритм на основе PBFT. Всего существует n валидаторов с максимумом F произвольно ошибочных.

Мы рассматриваем слабосинхронную сеть, где противник может переупорядочивать или задерживать сообщения на неопределенный срок, с единственным условием, что сообщения в конечном итоге прибывают. Модель коммуникации предполагает, что каждый валидатор имеет канал друг с другом валидатор, хотя на практике сообщения, вероятно, будут распространяться сплетнями.

Алгоритм продолжается в раундах (начиная с 0), причем первичный выбирается с помощью детерминированной функции первичного выбора Primary(round).

Алгоритм первичного выбора не полностью определен, но будет аналогичен тому, как rth validator mod принимает количество валидаторов.

Основная задача состоит в том, чтобы предложить блок цепи реле для включения. Мы также рассматриваем хэш-функцию H, которая отображает предложения в их дайджесты таким образом, что коллизии имеют незначительную вероятность.


```
PROPOSE(round, Proposal)
PREPARE(round, Digest)
COMMIT(round, Digest)
ADVANCE(round)
```

Терминология:

threshold-prepare: набор подписанных Сообщений PREPARE (r, D) от по крайней мере N - F валидаторов с r и D все равно.
обоснование: набор подписанных Сообщений фиксации (r, D) от по крайней мере N - F валидаторов с r и D все равно.
threhsold-аванс: набор подписано предварительное(р) сообщений не менее N - валидаторы Ф С Р все же.

Описание алгоритма:

При начале раунда r каждый валидатор устанавливает таймаут раунда, который экспоненциально увеличивается с числом раунда. Основной(р) создает предложение p И рассылает подписанным предлагаю(Р, П).
При получении предложения(Р, П) подписан основным(Р), А В валидатор оценивает действительность P. если p является действительной в мультикаст подписанный подготовить(р, ч(п)), если в уже транслировать подготовить сообщение в р.
После наблюдения за порог-подготовить для R и H(p), то валидатор мультикаст подписанный фиксации(р, ч(п)), если он уже вещали вперед(р).
При таймауте или наблюдении F + 1 подписанное продвижение (r) сообщения, мультикаст валидатора подписанное продвижение (r).
Увидев порог-продвижение для r, переходите к раунду r + 1.
Увидев обоснование для некоторого дайджеста H (X), выйдите с H(X).

Существует два дополнительных правила блокировки:

Валидаторы могут предлагать, подготавливать и фиксировать предложение только с порога-подготовьте с самым высоким раундом, если он существует.
Валидаторы должны рассмотреть любое предложение от порога-подготовьте с самым высоким раундом засвидетельствованным действительным, если он существует.

Чтобы этот консенсусный протокол был безопасным и живым, мы предполагаем n = 3f + k, k > 0.

Первое правило необходимо для сохранения" безопасного " имущества:

Если F + k хорошие валидаторы многоадресная фиксация (r, D), дефектные валидаторы f могут создать действительное обоснование для D. таким образом, если другой дайджест D' будет завершен хорошими валидаторами n - f в другом раунде, два предложения были завершены.

Однако, если эти валидаторы f + k заблокированы на D, нет никакого способа для остальных валидаторов F good порог-подготовить или даже совершить другой дайджест D ' даже в сочетании с ошибочными валидаторами f, как 2f < n-f.

Второе правило, необходимое для сохранения "живости" недвижимость на улице:

Валидаторы вообще откажутся рассматривать любое предложение, содержащее кандидата, за которого он получил даже один голос недействительности, как действительное.

Если неисправные валидаторы F становятся неактивными, когда любой хороший валидатор заблокирован,это потребует полного сотрудничества хороших валидаторов 2f + K. Если дефектные валидаторы могут убедить даже одного валидатора не принимать заблокированное предложение (например, путем трансляции Недействительного голосования за кандидата, содержащегося в нем), консенсус будет остановлен. Таким образом, мы вводим второе правило, чтобы несколько ослабить функцию действительности в том случае, если предложение уже подготовлено для принятия сетью.

## State

Состояние цепи ретрансляции имеет сходство с Ethereum: "объекты", содержащиеся в ней, являются отображением из идентификатора ObjectID в код (SHA3 кода Wasm) и хранением (корень Merkle-trie для набора отображений H256 в байты). Объекты представляют собой мягкие пакеты кода Wasm с несколькими внешними объектами, открытыми для них как пользовательские функции, в первую очередь возможность вызова других объектов и доступа к собственному хранилищу.

Примечательно, что информация о балансе или nonce не хранится непосредственно в государстве. Балансы, как правило, не нужны, так как точки ретрансляционной цепи не являются криптовалютой как таковой и не могут быть переданы между владельцами напрямую. Nonces, для целей replay-protection управляются специализированным объектом аутентификации.

Собственности точками осуществляется двух объектов: разбивка объекта (который управляет долями точками пользователями) и Parachains объект (который контролирует все точки принадлежащие parachains). Передача между объектами Staking и Parachains происходит через подписанную транзакцию, включенную в цепь реле.

```
state := ObjectID -> ( code_hash: Hash, storage_root: Hash )
```
Каждый объект выполняет определенные функции (хотя со временем они могут быть расширены или сокращены по мере внесения изменений в протокол). Для PoC-1 объекты:

    Объект 0: Никто. Базовый объект пользовательского уровня. Можно запрашивать не чувствительны всеобщего сведения (как block_number(), block_hash()). Представляет источник внешней транзакции, прошедший проверку подлинности на уровне пользователя.
    Объект 1: Системы. Обеспечивает низкоуровневое изменяемое взаимодействие с заголовком, в частности set_digest (). Представляет источник системы, который включает все принятые валидатором неподписанные транзакции.
    Объект 2: Администрация. Хранит и администрирует параметры цепочки низкого уровня. Может в одностороннем порядке считывать и заменять код / хранилище во всех объектах &c. Принимает и выступает на голосовании. Действует как точка входа в выполнение блока / состояние-переход.
    Объект 3: Консенсус. Хранит все вещи консенсус и код логика консенсуса реле-цепи. Требует быть информированным о текущем наборе валидатора и может быть запрошен для профилей поведения. Валидатор проверяет подписи.
    Объект 4: Фиксация. Хранит все, что нужно сделать с алгоритмом доказательства ставок, особенно в настоящее время. Информирует объект консенсуса о текущем наборе средств проверки. Хозяева Кол.-голосование.
    Объект 5: Парашюты. Хранит все вещи, чтобы сделать с parachains в том числе общей суммы parachain, реле-цепь-родные балансы пользователей, которые могут быть использованы (в parachain), функция проверки, информацию и текущее состояние очереди. Сбрасывается в начале каждого блока, чтобы позволить сообщениям предыдущего блока к цепочке ретрансляции выполняться.
    Объект 6: Проверка Подлинности. Управляет проверкой подписей транзакций и защитой воспроизведения.
    Объект 7: Метка Времени. Сохраняет Текущее время. Раз в блоке объектом системы.

Для PoC-1 эти объекты, вероятно, будут встроенными, хотя в конечном итоге они должны быть реализованы как модули Wasm и динамически скомпилированы/выполнены.

## Execution Environment

Функция перехода в основном похожа на неупорядоченный вариант Ethereum, который удаляет весь баланс / nonce и" открытую "способность создавать" смарт-контракты " (объекты). Основные моменты:

    Использование движка Wasm для выполнения кода, а не EVM.
    Транзакции включают имя функции и вызов-выполнение "автоматически" отправляет функции в теле кода.
    Wasm intrinsics заменяет некоторые из функций/опкодов externality EVM, остальные ненужны:
        BLOCKHASH - > n /a (предоставляется никем.block_hash())
        Номер - > n /a (предоставлено никем.текущее количество())
        LOG* - > System.deposit_log()
        CREATE - > deploy (который берет новый индекс объекта и clobbers любой существующий код там; никакая функция инициализации не выполняется).
        Вызов - > вызов или call_const
        RETURN - > n /a (возврат в Wasm)
        CALLDATA* -> Н/А (параметры передаются в функцию предварительного deserialised из сделки с помощью функции подписи как намек)
        Метка -> Н/А (есть отметка объекта)
        Баланс/происхождения/GASPRICE/EXTCODE/фонда/сложности/GASLIMIT/ГАЗ/CALLCODE/DELEGATECALL/суицид -> н/д

## Block Processing

Таким образом, нормативный механизм обработки блока:

    проверьте правильность данных блока RLP с правильными форматами элементов; пусть block-структурированные данные;
    пусть Заголовок: = блок.заголовок;
    проверьте Заголовок.transactions_root правильно отражает блок.сделки;
    проверьте, что проверенный блок хранится узлом для заголовка.номер-1 и что его хэш-Заголовок является заголовком.parent_hash (в нормативном случае это будет текущая проверенная головка);
    пусть s-состояние в конце выполнения заголовка блока.parent_hash; пусть validator_set: = S. консенсус.validator_set (); убедитесь, что S. консенсус.check_seal (validator_set, блок) не прерывается; (это проверит сегмент сигнатур перечисляет правильное количество действительных подписей валидатора с набором валидатора, заданным объектом консенсуса. Мы требуем check_seal без гражданства с любой необходимой государственной информации прошло через validator_set для облегчения parallelisation.)
    убедитесь, что S является изменяемым, но что любые мутации не фиксируются, за исключением случаев, когда явно указано;
    Системные вызовы S. Администрирование.execute_block (блок); если он прерывается, отменить / отбросить S и блок считается недействительным.

### Invalid blocks

Если блок считается недействительным и должен быть отмечен, чтобы он не обрабатывался снова.

# Data formats

Структуры данных кодируются rlp с использованием нормативного Ethereum RLP.

## Block

Блок содержит всю информацию, необходимую для оценки блока релейной цепи. Она включает в себя внешние данные, специфичные для цепи реле.

```
Block: [
	header: Header,
	transactions: [ Transaction ],
	signatures: [ Signature ]
]
```

## Transaction

Транзакции являются изолируемыми компонентами внешних данных, используемыми в блоках для описания конкретных коммуникаций извне системы перехода состояния. Как правило, они приходят из внешнего мира (в этом случае они будут содержать подписи для подтверждения их происхождения и появляются в блоке как SignedTransactions) или они придут с молчаливого согласия блока проверки (в этом случае они будут отображаться в блоке как сделка будет выполнена, как если бы исходящее от системы объекта).

```
Transaction: [
	destination: ObjectID,
	function_name: bytes,
	parameters: [ ... ]
]
```

```
SignedTransaction: [
	unsigned: UnsignedTransaction,
	signature: Signature
]
```

Для описания формата подписи полезно определить объект UnsignedTransaction, который является Транзакцией с nonce, или индексировать, чтобы заставить заказ на транзакции, поступающие из того же источника, чтобы избежать атак воспроизведения.

```
UnsignedTransaction: [
	tx: Transaction,
	nonce: TxOrder
]
```

destination - индекс объекта, по которому будет вызвана функция.
function_name-имя функции объекта, который будет вызван.
параметры-это параметры, передаваемые в функцию; это богатый сегмент данных, который будет интерпретироваться в соответствии с прототипом функции. Он должен содержать ровно столько элементов, сколько является прототипом функции; если какой-либо из элементов прототипа функции структурирован по своей природе, то структура этих параметров должна отражать это. Более конкретное сопоставление между RLP и Wasm ABI будет обеспечено в надлежащее время.

## Header

Заголовок хранит или криптографически ссылается на всю внутреннюю информацию, относящуюся к блоку.

```
Header: [
	parent_hash: Hash,
	number: BlockNumber,
	state_root: Hash,
	transaction_root: Hash,
	digest: Digest
]
```

Дайджест-это второсортный элемент данных, содержащий сводную информацию о действиях, произошедших в блоке, который полезен для light-клиентов. Для PoC-1 это набор бревен и немного поля активных парашютов. Его содержимое задается через Системный объект.

```
Digest: [
	parachain_activity_bitfield: bytes,
	logs: [ bytes ]
]
```

Формат дайджеста не следует считать неизменной частью основного протокола. Изменение его не является тривиальной задачей (так как Лайт-клиенты будут зависеть от его формата), но возможно, так как все обращения к его внутренностям осуществляются программно-кодированными объектами.

## Candidate Parachain block

Кандидат parachain блоки передаются от сортировщиков до валидаторов и экспресс-информации о последних состояния parachain. Если проверено и принято, то большая часть этой информации дублируется на состояние цепи реле под объектом Parachains (исключение block_data).


```
Candidate: [
	parachain_index: ChainID,
	collator_signature: Signature,
	unprocessed_ingress: [ [ [ bytes ] ] ],
	block_data: bytes
]
```

unprocessed_ingress приказал заблокировать номер (по возрастанию), а затем по индексу parachain, а затем по индексу сообщение.

Квитанции кандидата являются окончательными данным на реле цепи. Они подписаны и опубликованы соответствующие валидаторы parachain и распространялись среди сети. Они могут быть получены из любого релейно-цепного синхронизированного узла и кандидата, запустив соответствующую функцию проверки parachain.

```
CandidateReceipt: [
	parachain_index: ChainID,
	collator: AccountID,
	head_data: bytes,
	balance_uploads: [ ( AccountID, Balance ) ],
	egress_queue_roots: [ ( ChainID, Hash ) ],
	fees: Balance
]
```

parachain_index является уникальным идентификатором для этого parachain.
egress_queue_roots-массив корней выходных очередей. Многие/большинство записей могут быть пустыми, если parachain мало исходящие соединения с другими цепями.
balance_uploads - это набор идентификаторов счетов AccountID и положительных дельт баланса U256, которые представляют собой балансы, которые должны быть разблокированы на цепи реле (поскольку точки были недоступны на самом парашюте).

# Transaction routing

Важно отметить, что валидаторы ретрансляционной цепи почти ничего не делают в отношении маршрутизации транзакций. Всю тяжелую работу в плане отслеживания исходящих (исходящих) очереди осуществляется сортировщиков.

Для каждого блока каждого parachain, существует набор исходящие сообщения друг другу parachain. Если нет государства-перехода произошло на parachain, то это множество будет пустым.

Для parachain p, посылающего сообщение parachain Q, в блоке номер B мы можем сказать chain[B].parachain[П].выход[Q] представляет эту очередь. Если по какой-либо причине Q не обрабатывает эту очередь, то элементы не каким-либо образом перенаправляются или копируются в цепочку[B + 1].parachain[П].выход[Q] скорее это отдельная очередь в целом, описывающая выходные сообщения, полученные из блока B + 1 P. В этом случае при проверке кандидата на Q после блока B выходными очередями из B необходимо будет управлять в логике проверки.

Роль сортировщиков включает в себя отслеживание очереди все остальные parachains' выход на свою цепочку и соединив их в трехмерный массив, когда они производят блок parachain :


```
[
	chain_1: IngressQueues, chain_2: IngressQueues, ...
]
```

Нет пункта для самого parachain; предполагается, что parachain нет необходимости отправлять сообщения самому себе.

Каждый элемент IngressQueues содержит несколько массивов байтовых Сообщений. Число таких матриц равно количеству блоков, которые прошли с последнего блока parachain был завершен (каждый правильно доработать блок parachain обязательно топит очереди все остальные parachain по выходу к себе).

```
IngressQueues: [
	earliest_block: [ bytes, ... ],
	next_earliest_block: [ bytes, ... ],
	...
	latest_block: [ bytes, ... ]
]
```

Допустимо для любого из этих [байт, ... ] массивы должны быть пустыми.
### Specifics

Каждая условная Выходная очередь для заданной цепочки блоков[B].parachain[П].выход[Q] относится к определенному набору данных, хранящихся в состоянии. Специфичный для конечного состояния s блока B, мы индексируем цепочку ключей[B].parachain[П].egress_queues[Q] в триэ. Для любого заданного блока корни всех необработанных выходных очередей (в конце перехода состояния блока) хранятся в его состоянии: S. Parachains.chain_state (P).egress_queue_roots[Q].

Как часть своей деятельности, функция утверждения блока кандидата требует unprocessed очередей входа (т. е. уместных других очередей выхода parachain). Эти очереди предоставляются средством сортировки как часть блока-кандидата, но проверяются внешне функцией проверки "изначально" средством проверки. Технически они могут быть подтверждены как часть функции проверки, но это будет означать дублирование кода между всеми парашютами и неизбежно будет медленнее и потребует существенных дополнительных данных, поскольку данные свидетелей, касающиеся исторической информации о выходе, были составлены и переданы. Требование к самому узлу валидатора предварительно проверить эту информацию позволяет избежать этого.

Кандидат задает новый набор корней очереди выхода, и функция проверки гарантирует, что они отражены переходом состояния парашютиста.

Исходный и конечный индексы parachain.

Этот набор Сообщений определяется collator, Задается в блоке candidate и проверяется как часть функции Validity. Набор Сообщений должен отвечать определенным критериям, включая соблюдение ограничений на количество и размер исходящих очередей.

Назовем четыре параметра цепочки:

routing_max_messages: максимальное количество сообщений, которые могут быть отправлены из блока в общей сложности.
routing_max_messages_per_chain: максимальное количество сообщений, которые могут быть отправлены из блока в одну цепочку.
routing_max_bytes: максимальное количество байт, которое могут занимать все сообщения, которые могут быть отправлены из блока в целом.
routing_max_bytes_per_chain: максимальное количество байтов, которое могут занимать все сообщения, которые могут быть отправлены из блока в одну другую цепочку.

Часть процесса проверки включает в себя проверку соблюдения этих четырех ограничений блоком-кандидатом. Это делается в то же время как расчет платы calculate_fees.

# Interface Definitions

## Types

- `ObjectID : U64`
- `AccountID : H160`
- `Balance : U256`
- `ChainID : U64`
- `Hash : H256`
- `BlockNumber : U64`
- `Proportion : U64`
- `Timestamp : U64`
- `TxOrder : U64`

### ParachainState


```
ParachainState : {
	head_data: bytes,
	balance: Balance,
	user_balances: AccountID -> Balance,
	balance_downloads: AccountID -> ( Balance, bytes ),
	egress_roots: [ Hash ]
}
```

## Static Constants

Они не зависят от государства. Они просто плавают в глобальной среде и присущи самой цепочке или узлу.

- `chain_id() -> ChainID`
- `sender() -> ObjectID`

## State-based APIs
### Environment (0)

- READONLY `block_number(self) -> BlockNumber`
- READONLY `block_hash(self, BlockNumber) -> Hash`

### System (1)
- SYSTEM `set_digest(mut self, preserialised_rlp_digest: bytes)`

### Administration (2)
- SYSTEM `execute(mut self, block: Block)`
- READONLY `current_user(self) -> AccountID`
- SYSTEM `deposit_log(mut self, data: bytes)`
- SYSTEM `set_active_parachains(mut self, data: bytes)`

### Consensus (3)
- READONLY `validators(self) -> [ AccountID ]`
- SYSTEM `set_validators(self, validators: [ AccountID ])`
- SYSTEM `flush_statistics(mut self) -> Statistics`

### Staking (4)
- READONLY `era_length(self) -> BlockNumber`
- READONLY `balance(self, AccountID) -> Balance`
- USER `move_to_parachain(mut self, chain_id: ChainID, value: Balance)` User-level function to move funds onto a parachain. Calls `Parachains.credit_parachain`.
- SYSTEM `credit_staker(mut self, value: Balance)` System-level function to be called only by Parachains object when funds have left that object and are to be credited here.
- USER `stake(mut self, minimum_era_return: Proportion)`
- USER `unstake(mut self)`
- USER `complain(mut self, complaint: Complaint)`

Staking происходит в партиях блоков, называемых эра. В конце каждой эры выплаты обрабатываются на основе статистики, накопленной объектом консенсуса, и набор валидаторов подтверждается или изменяется. Разбивка профиля учетной записи (т. е. параметров, которые определяют, когда его баланс будет использоваться в подпор системы) может быть задан с помощью кольев и функции частично. Оба специально нацелены на следующую эру. Информация о ставках сохраняется между эра, и дальнейшие вызовы не нужны, если пользователь не хочет изменять свой профиль. Каждый счет имеет связанный с ним баланс (баланс); этот баланс нельзя разделить между различными профилями.

### Parachains (5)

    - READONLY `chain_ids(self) -> [ ChainID ]`
- READONLY `validation_function(self, chain_id: ChainID) -> Fn(consolidated_ingress: [ ( ChainID, bytes ) ], balance_downloads: [ ( AccountID, Balance ) ], block_data: bytes, previous_head_data: bytes) -> (head_data: bytes, egress_queues: [ [ bytes ] ], balance_uploads: [ ( AccountID, Balance ) ])`
- READONLY `validate_and_calculate_fees_function(self, chain_id: ChainID) -> Fn(egress_queues: [ [ bytes ] ], balance_uploads: [ ( AccountID, Balance ) ]) -> Balance`
- READONLY `balance(self, chain_id: ChainID, id: AccountID) -> Balance`
    - Только для чтения verify_and_consolidate_queues(самовыдвижение, unprocessed_ingress: [ [ [ байт ] ] ]) -> [ (chain_id: ChainID, сообщение: байт) ]: unprocessed_ingress разыменовывается в порядке от внешнего к внутреннему: блок возраст (сначала старые), parachain идентификатор, сообщение индексу. Это прерывается, если unprocessed_ingress содержит элементы, которые не отражают исторические очереди выхода parachain. Он также прерывается, если он не содержит все элементы из выходных очередей, связанных для этой цепочки, которые еще не были обработаны этой цепочкой. В противном случае он возвращает все сообщения (в байтах пользования) прошел в unprocessed_ingress, приказал заблокировать возраста (убыванию), затем по ID parachain, затем по индексу сообщение и в паре с исходным кодом parachain.
    - Как readonly chain_state(самовыдвижение, chain_id: ChainID) -> ParachainState возвращает состояние chain_id parachain.
    Move_to_staking пользователей(мут самостоятельно, chain_id: ChainID, значение: баланс) на уровне пользователя функция, которая перемещает пользователя-баланс от этого объекта, связанного с chain_id parachain на ставку объекта. Реализовано за счет уменьшения S. Parachains.баланс и S. парашюты.chain_state[chain_id].баланс [sender()] и создание его на цепочке Staking с использованием Staking.credit_staker.
    - Система credit_parachain(мут самостоятельно, chain_id: ChainID, значение: баланс) на уровне системы, функция может быть вызвана только поставив объект, когда средства осталось, что объект и подлежащие зачислению здесь.
    - Скачать руководство пользователя(мут самостоятельно, chain_id: ChainID, значение: Остаток на счете, команды: байт) обозначает часть баланса должны быть загружены в parachain. На самом деле это означает уменьшение баланса пользователя для отправителя() parachain chain_id по значению и выдачу внеполосной инструкции balance_downloads для parachain через его следующую функцию проверки. Так что parachain может быть сказано, что делать с точками (например, чьи parachain на основе счета должны быть зачислены) обучения. Это может разумно кодировать больше, чем просто адрес назначения, но он остается для parachain STF, чтобы определить, что такое Кодировка.
    - Система update_heads(мут самостоятельно, candidate_receipts: [ ( ChainID, CandidateReceipt ) ])

    Рассмотрим: сложите balance_downloads и balance_uploads в head_data; упростит функцию проверки и сделает ее немного более абстрактной (хотя загрузка и выгрузка потребует знания внутренних компонентов head_data).

    Рассмотреть: возможность сообщения между parachains содержать точек. для использования при отправке кучу точек из одной цепи в другую, это бы значительно упростило (в настоящее время, вам придется создать новый секретный адрес, загрузить точки в реле-цепи Parachains объекта через parachain Техас, перевод на ставку счета, а затем обратно в новый parachain (два реле цепи ВМС США), то проблема в скачать Техас (еще одно реле цепь Техас)). Это может быть оптимизировано для трех транзакций, если парашюты могут перемещаться между собой, но это все еще много faff для одной смысловой операции.

### Authentication (6)

- READONLY `validate_signature(self, tx: Transaction) -> ( AccountID, TxOrder )`
- READONLY `nonce(self, id: AccountID) -> TxOrder`
- SYSTEM `authenticate(mut self, tx: Transaction) -> AccountID`

### Timestamp (7)

- READONLY `timestamp(self) -> Timestamp`
- SYSTEM `set_timestamp(mut self, Timestamp)`

# Notes

Все транзакции пользователя должны как можно скорее записать плату в их исполнение и, сделав это, не должны прерываться.

# Implementation Notes

## Administration (2)

Объект администрирования содержит execute_block, который обрабатывает всю функцию перехода состояния. Некоторые из функций, которые он предоставляет, предоставляются через его эфемерное хранилище (в частности, deposit_log, current_user и set_active_parachains).

Что касается execute_block, грубый псевдо-код:

для каждой транзакции tx в блоке.сделки:
если Техас.подпись существует (подписанная транзакция):
пусть функция current_user := Разрешение.проверка(Техас). Если выполнение прерывается, блок прерывается и считается недопустимым.
убедитесь, что current_user возвращается, если Администрирование.current_user вызывается во время выполнения этой транзакции.
пусть звонящий: = никто
в противном случае, если Техас.подпись не существует (неподписанная транзакция):
пусть звонящий := система
вызов S[tx.пункт назначения][Техас.function_name] (tx.парамы...) от абонента учетной записи, где state S-конечное состояние блока. Если выполнение прерывается, блок прерывается и считается недопустимым.
сброс current_user для обеспечения администрирования.current_user прерывается при вызове.

Отмечать:

Транзакции могут включать подписанные заявления от внешних субъектов, таких как рыбаки или стейкеры, но также могут содержать неподписанные заявления, которые просто записывают "принятую" истину (или часть внешних данных). Если транзакция не подписана, но включена как часть блока, то ее отправителем является System. Метка времени вызова транзакции.set_timestamp был бы примером этого. Когда валидатор подписывает блок как кандидат ретрансляционной цепи, они неявно ратифицируют каждое из заявлений блоков как действительные истины.

Одно заявление о том, что появится в блоке отобранных кандидатов parachain. В данном случае это простое сообщение для S. Parachains.update_heads. Этот вызов гарантирует, что любые балансы точки на parachain, которые требуются как сборы за выходную очередь, сожжены.
## Parachains (5)

### Validating & Processing

Проверка цепи ретрансляции происходит в трех контекстах:

при попытке синхронизации цепочки;
когда вы строите блок, и вам нужно определить действительность кандидата на парашюте, которому Вы не назначены;
когда вы пытаетесь проверить кандидата parachain, возможно, как рыбак, возможно, как валидатор, который строит блока, возможно, в качестве валидатора, кто отвечает на жалобу.

Для первого контекста достаточно просто выполнить все транзакции в блоке. Проверка происходит неявно через существование неподписанной транзакции update_heads, которая появляется в блоке, подписанном валидаторами.

Второй контекст очень похож на первый, за исключением того, что update_heads запускается вручную и подтверждается доступность исходного блока.

Во всех контекстах не предполагается, что у вас есть история цепочки. Все операции могут быть выполнены исключительно путем просмотра состояния цепочки" current " (относительно проверяемого блока).

На последнем контексте, конкретные шаги для проверки кандидата parachain на государство с:

Убедитесь, что блок-кандидат является структурно обоснованным. Пусть кандидатом будут структурированные данные.
Получить подпись collator для кандидата и пусть collator: = ecrecover (кандидат.collator_signature). Примечание: это еще не используется в STF; только в алгоритме консенсуса при определении предпочтения по сравнению с возможными кандидатами.
Позвонить С. Parachains.validate_ingress(кандидата), и если он прерывается, то это является недопустимым кандидат parachain. (Эта функция обеспечивает этого кандидата.unprocessed_ingress правильно отражает все необработанные очереди исходящих от всех других parachains, как описано в Parachains хранения объекта. Если это не так, то это недопустимое кандидат parachain и прерывает функцию.)
Пусть consolidated_ingress := С. Parachains.verify_and_consolidate_queues (кандидат.unprocessed_ingress), и если это прерывает тогда, это-недопустимый кандидат parachain.
С С. Parachains.chain_state[кандидат.parachain_index] как цепь:
Пусть previous_head_data: = chain.head_data
Пусть balance_downloads: = взять цепочку.balance_downloads (где взять означает атомарно очистить RHS и вернуть его)
Давайте проверять := С. Parachains.validation_function (кандидат.parachain_index)
Пусть (head_data, egress_queues, balance_uploads) := проверить(consolidated_ingress, balance_downloads, block_data, previous_head_data); если он прерывается, то это является недопустимым кандидат parachain.
Пусть validate_and_calculate_fees := С. Parachains.validate_and_calculate_fees_function (кандидат.parachain_index)
Гарантируйте, что все ограничения относительно выходных очередей и загрузок баланса соблюдены и вычисляют сборы: пусть сборы: = validate_and_calculate_fees (egress_queues, balance_uploads), и если это прерывает, то это-недопустимый кандидат parachain.
Если сборы > цепь.баланс, то это недопустимое кандидат parachain.
Давайте расписку := CandidateReceipt( parachain_index, сортировально-подборочной машины, head_data, to_index_keyed_trie_roots(egress_queues), balance_uploads, сборов )

После всех parachain кандидатов были созданы, давайте квитанции сопоставление ChainID -> CandidateReceipt тогда:

Ввести в действие квитанцию кандидата, вызвав S. Parachains.update_heads (поступления)

### Pseudocode for update_heads

```
update_heads(
	receipts: ChainID -> CandidateReceipt
) {
	constant routing_from: ChainID -> { ChainID } = S.calculate_routing_from();

	foreach source in receipts.keys():
		with chain as S.Parachains.chain_state[source];
		with receipt as receipts[source];
		foreach dest in receipts.keys():
			if routing_from[source].contains(dest):
				chain.egress[dest].clear();
		chain.egress[dest].push(receipt.egress_queue_roots[dest]);
		chain.head_data := receipt.head_data
		chain.balance -= receipt.fees
		foreach (id, value) in receipt.balance_uploads:
			chain.user_balances[id] += receipt.value
}

unrouted_queue_roots(from: ChainId, to: ChainId) -> [Root] {
	egresses[to][from].clone()
}
```

## Authentication (6)

Объект аутентификации позволяет участникам искать подпись, хэш сообщения и nonce в AccountID (H160 на данный момент). Это позволяет аутентифицировать транзакцию, которая изменяет состояние и гарантирует, что те же транзакции не могут быть повторно отправлены. Он также позволяет проверить транзакцию, которая не изменяет состояние (и, таким образом, не дает никакой защиты от воспроизведения, за исключением транзакций, которые ранее были аутентифицированы). Вы также можете получить индекс заказа (он же nonce в Ethereum) для любого идентификатора учетной записи.

    Только для чтения проверки(самовыдвижение, Техас: транзакция) -> (код: методами accountid, сейчас: TxOrder, когда: TxOrder) возвращает идентификатор записи, которая подписана Техас, и заказ такой сделке при сравнении текущего заказа сейчас. Если now == when, то сделка может быть действительно включена / выполнена. Если подпись недействительна, будет прервана.
    Система authenticate (mut self, tx: Transaction) -> AccountID возвращает идентификатор счета, который подписал tx iff, tx может быть действительно выполнен на состоянии, как это. Прерывает иначе.
    Readonly order (self, id: AccountID) - > u64 возвращает индекс текущего заказа идентификатора счета.

Функция authenticate, скорее всего, просто вызовет функцию validate. Пример реализации:

```
fn authenticate(mut self, tx: Transaction) -> AccountID {
	let (id, now, when) := self.validate(tx);
	if (now == when) {
		self.nonce[id]++;
		return id;
	}
	abort();
}
```

Функция validate проверяет действительность подписи ECDSA (r, s, v). Это должна быть подпись на хэше keccak256 кодировки RLP:


```
[
	transaction: UnsignedTransaction,
	chain_id: ChainID
]
```

Значение V подписи должно быть основано на стандартном v_standard ([27, 28]):

```
v := v_standard - 26 + chain_id * 2
```

### Q&A

    Как ожидается, что сборы будут синхронизированы с итогами баланса цепи? Существует три случаев, когда оплачиваются действия пользователей: вести непосредственно с разбивки объекта, заключение сделок непосредственно с Parachains объекта и выдачу некоторых parachain систем обучения (например, чтобы загрузить баланс в Parachains объекта или отправлять сообщения в другой parachain). Первые два списана со счета пользователя напрямую (очень рано) часть исполнения сделки. Последнее относится непосредственно на баланс parachain по. Предполагается, что parachain состояние-функция переходов (СТП) обеспечивать, где это необходимо пользователю достаточно заряжен комиссии от parachain-баланс точек; в случае отправки сообщений, это будет выглядеть как необходимо сжечь ДОТ жетоны для parachain выдавать исходящего сообщения в свой выходной очереди. В случае загрузки точек, это, вероятно, будет простое сокращение количества точек, которое появляется в upload_balances по сравнению с теми, которые сгорели на самом парашюте (которые, если бы не сборы, были бы равны).

